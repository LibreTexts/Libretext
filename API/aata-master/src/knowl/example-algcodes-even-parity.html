<!DOCTYPE html>
<html lang="en-US">
<!--**************************************-->
<!--*    Generated from PreTeXt source   *-->
<!--*    on 2019-03-30T21:52:57-07:00    *-->
<!--*                                    *-->
<!--*      https://pretextbook.org       *-->
<!--*                                    *-->
<!--**************************************-->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="robots" content="noindex, nofollow">
</head>
<body>
<article class="example-like"><h6 class="heading">
<span class="type">Example</span> <span class="codenumber">8.1.3</span>.</h6>
<p><dfn class="terminology">Even parity</dfn>, a commonly used coding scheme, is much more efficient than the simple repetition scheme. The <abbr class="acronym">ASCII</abbr> (American Standard Code for Information Interchange) coding system uses binary \(8\)-tuples, yielding \(2^{8} = 256\) possible \(8\)-tuples. However, only seven bits are needed since there are only \(2^7 = 128\) <abbr class="acronym">ASCII</abbr> characters. What can or should be done with the extra bit? Using the full eight bits, we can detect single transmission errors. For example, the <abbr class="acronym">ASCII</abbr> codes for A, B, and C are</p>
<div class="displaymath">
\begin{align*}
\text{A} &amp; = 65_{10} = 01000001_{2},\\
\text{B} &amp; = 66_{10} = 01000010_{2},\\
\text{C} &amp; = 67_{10} = 01000011_{2}\text{.}
\end{align*}
</div>
<p>Notice that the leftmost bit is always set to 0; that is, the \(128\) <abbr class="acronym">ASCII</abbr> characters have codes</p>
<div class="displaymath">
\begin{align*}
00000000_{2} &amp; = 0_{10},\\
&amp; \vdots\\
01111111_{2} &amp; = 127_{10}\text{.}
\end{align*}
</div>
<p>The bit can be used for error checking on the other seven bits. It is set to either \(0\) or \(1\) so that the total number of \(1\) bits in the representation of a character is even. Using even parity, the codes for A, B, and C now become</p>
<div class="displaymath">
\begin{align*}
\text{A} &amp; = 01000001_{2},\\
\text{B} &amp; = 01000010_{2},\\
\text{C} &amp; = 11000011_{2}\text{.}
\end{align*}
</div>
<p>Suppose an A is sent and a transmission error in the sixth bit is caused by noise over the communication channel so that  \((0100\; 0101)\) is received. We know an error has occurred since the received word has an odd number of \(1\)s, and we can now request that the codeword be transmitted again. When used for error checking, the leftmost bit is called a <dfn class="terminology">parity check bit</dfn>.</p>
<p>By far the most common error-detecting codes used in computers are based on the addition of a parity bit. Typically, a computer stores information in \(m\)-tuples called <dfn class="terminology">words</dfn>. Common word lengths are \(8\text{,}\) \(16\text{,}\) and \(32\) bits. One bit in the word is set aside as the parity check bit, and is not used to store information. This bit is set to either \(0\) or \(1\text{,}\) depending on the number of \(1\)s in the word.</p>
<p>Adding a parity check bit allows the detection of all single errors because changing a single bit either increases or decreases the number of \(1\)s by one, and in either case the parity has been changed from even to odd, so the new word is not a codeword. (We could also construct an error detection scheme based on <dfn class="terminology">odd parity</dfn>; that is, we could set the parity check bit so that a codeword always has an odd number of \(1\)s.)</p></article><span class="incontext"><a href="section-error-detecting-correcting-codes.html#OzI">in-context</a></span>
</body>
</html>
